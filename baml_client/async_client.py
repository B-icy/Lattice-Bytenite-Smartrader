# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

import typing
import typing_extensions
import baml_py

from . import stream_types, types, type_builder
from .parser import LlmResponseParser, LlmStreamParser
from .runtime import DoNotUseDirectlyCallManager, BamlCallOptions
from .globals import DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME as __runtime__


class BamlAsyncClient:
    __options: DoNotUseDirectlyCallManager
    __stream_client: "BamlStreamClient"
    __http_request: "BamlHttpRequestClient"
    __http_stream_request: "BamlHttpStreamRequestClient"
    __llm_response_parser: LlmResponseParser
    __llm_stream_parser: LlmStreamParser

    def __init__(self, options: DoNotUseDirectlyCallManager):
        self.__options = options
        self.__stream_client = BamlStreamClient(options)
        self.__http_request = BamlHttpRequestClient(options)
        self.__http_stream_request = BamlHttpStreamRequestClient(options)
        self.__llm_response_parser = LlmResponseParser(options)
        self.__llm_stream_parser = LlmStreamParser(options)

    def with_options(self,
        tb: typing.Optional[type_builder.TypeBuilder] = None,
        client_registry: typing.Optional[baml_py.baml_py.ClientRegistry] = None,
        collector: typing.Optional[typing.Union[baml_py.baml_py.Collector, typing.List[baml_py.baml_py.Collector]]] = None,
        env: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        on_tick: typing.Optional[typing.Callable[[str, baml_py.baml_py.FunctionLog], None]] = None,
    ) -> "BamlAsyncClient":
        options: BamlCallOptions = {}
        if tb is not None:
            options["tb"] = tb
        if client_registry is not None:
            options["client_registry"] = client_registry
        if collector is not None:
            options["collector"] = collector
        if env is not None:
            options["env"] = env
        if on_tick is not None:
            options["on_tick"] = on_tick
        return BamlAsyncClient(self.__options.merge_options(options))

    @property
    def stream(self):
      return self.__stream_client

    @property
    def request(self):
      return self.__http_request

    @property
    def stream_request(self):
      return self.__http_stream_request

    @property
    def parse(self):
      return self.__llm_response_parser

    @property
    def parse_stream(self):
      return self.__llm_stream_parser
    
    async def AnalyzeInsiderActivity(self, transactions: typing.List["types.InsiderTrade"],ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> types.InsiderActivitySummary:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            # Use streaming internally when on_tick is provided
            stream = self.stream.AnalyzeInsiderActivity(transactions=transactions,ticker=ticker,
                baml_options=baml_options)
            return await stream.get_final_response()
        else:
            # Original non-streaming code
            result = await self.__options.merge_options(baml_options).call_function_async(function_name="AnalyzeInsiderActivity", args={
                "transactions": transactions,"ticker": ticker,
            })
            return typing.cast(types.InsiderActivitySummary, result.cast_to(types, types, stream_types, False, __runtime__))
    async def AnalyzeNewsSentiment(self, articles: typing.List["types.NewsArticle"],ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> types.NewsSentimentAnalysis:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            # Use streaming internally when on_tick is provided
            stream = self.stream.AnalyzeNewsSentiment(articles=articles,ticker=ticker,
                baml_options=baml_options)
            return await stream.get_final_response()
        else:
            # Original non-streaming code
            result = await self.__options.merge_options(baml_options).call_function_async(function_name="AnalyzeNewsSentiment", args={
                "articles": articles,"ticker": ticker,
            })
            return typing.cast(types.NewsSentimentAnalysis, result.cast_to(types, types, stream_types, False, __runtime__))
    async def AnalyzeNewsSentimentForSentiment(self, ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> types.SentimentSource:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            # Use streaming internally when on_tick is provided
            stream = self.stream.AnalyzeNewsSentimentForSentiment(ticker=ticker,
                baml_options=baml_options)
            return await stream.get_final_response()
        else:
            # Original non-streaming code
            result = await self.__options.merge_options(baml_options).call_function_async(function_name="AnalyzeNewsSentimentForSentiment", args={
                "ticker": ticker,
            })
            return typing.cast(types.SentimentSource, result.cast_to(types, types, stream_types, False, __runtime__))
    async def AnalyzeOptionsSentiment(self, ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> types.OptionsFlow:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            # Use streaming internally when on_tick is provided
            stream = self.stream.AnalyzeOptionsSentiment(ticker=ticker,
                baml_options=baml_options)
            return await stream.get_final_response()
        else:
            # Original non-streaming code
            result = await self.__options.merge_options(baml_options).call_function_async(function_name="AnalyzeOptionsSentiment", args={
                "ticker": ticker,
            })
            return typing.cast(types.OptionsFlow, result.cast_to(types, types, stream_types, False, __runtime__))
    async def AnalyzePricePerformance(self, price_data: typing.List["types.PricePoint"],ticker: str,period: str,
        baml_options: BamlCallOptions = {},
    ) -> types.PriceAnalysis:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            # Use streaming internally when on_tick is provided
            stream = self.stream.AnalyzePricePerformance(price_data=price_data,ticker=ticker,period=period,
                baml_options=baml_options)
            return await stream.get_final_response()
        else:
            # Original non-streaming code
            result = await self.__options.merge_options(baml_options).call_function_async(function_name="AnalyzePricePerformance", args={
                "price_data": price_data,"ticker": ticker,"period": period,
            })
            return typing.cast(types.PriceAnalysis, result.cast_to(types, types, stream_types, False, __runtime__))
    async def AnalyzeSectorPerformance(self, 
        baml_options: BamlCallOptions = {},
    ) -> typing.List["types.SectorPerformance"]:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            # Use streaming internally when on_tick is provided
            stream = self.stream.AnalyzeSectorPerformance(
                baml_options=baml_options)
            return await stream.get_final_response()
        else:
            # Original non-streaming code
            result = await self.__options.merge_options(baml_options).call_function_async(function_name="AnalyzeSectorPerformance", args={
                
            })
            return typing.cast(typing.List["types.SectorPerformance"], result.cast_to(types, types, stream_types, False, __runtime__))
    async def AnalyzeSocialSentiment(self, ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> types.SentimentSource:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            # Use streaming internally when on_tick is provided
            stream = self.stream.AnalyzeSocialSentiment(ticker=ticker,
                baml_options=baml_options)
            return await stream.get_final_response()
        else:
            # Original non-streaming code
            result = await self.__options.merge_options(baml_options).call_function_async(function_name="AnalyzeSocialSentiment", args={
                "ticker": ticker,
            })
            return typing.cast(types.SentimentSource, result.cast_to(types, types, stream_types, False, __runtime__))
    async def CalculateTechnicalIndicators(self, price_data: typing.List["types.PricePoint"],ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> types.TechnicalIndicators:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            # Use streaming internally when on_tick is provided
            stream = self.stream.CalculateTechnicalIndicators(price_data=price_data,ticker=ticker,
                baml_options=baml_options)
            return await stream.get_final_response()
        else:
            # Original non-streaming code
            result = await self.__options.merge_options(baml_options).call_function_async(function_name="CalculateTechnicalIndicators", args={
                "price_data": price_data,"ticker": ticker,
            })
            return typing.cast(types.TechnicalIndicators, result.cast_to(types, types, stream_types, False, __runtime__))
    async def CalculateVolatilityMetrics(self, price_data: typing.List["types.PricePoint"],ticker: str,benchmark_data: typing.List["types.PricePoint"],
        baml_options: BamlCallOptions = {},
    ) -> types.VolatilityMetrics:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            # Use streaming internally when on_tick is provided
            stream = self.stream.CalculateVolatilityMetrics(price_data=price_data,ticker=ticker,benchmark_data=benchmark_data,
                baml_options=baml_options)
            return await stream.get_final_response()
        else:
            # Original non-streaming code
            result = await self.__options.merge_options(baml_options).call_function_async(function_name="CalculateVolatilityMetrics", args={
                "price_data": price_data,"ticker": ticker,"benchmark_data": benchmark_data,
            })
            return typing.cast(types.VolatilityMetrics, result.cast_to(types, types, stream_types, False, __runtime__))
    async def CompareToMarket(self, ticker: str,price_data: typing.List["types.PricePoint"],benchmark_ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> types.MarketComparison:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            # Use streaming internally when on_tick is provided
            stream = self.stream.CompareToMarket(ticker=ticker,price_data=price_data,benchmark_ticker=benchmark_ticker,
                baml_options=baml_options)
            return await stream.get_final_response()
        else:
            # Original non-streaming code
            result = await self.__options.merge_options(baml_options).call_function_async(function_name="CompareToMarket", args={
                "ticker": ticker,"price_data": price_data,"benchmark_ticker": benchmark_ticker,
            })
            return typing.cast(types.MarketComparison, result.cast_to(types, types, stream_types, False, __runtime__))
    async def ExtractResume(self, resume: str,
        baml_options: BamlCallOptions = {},
    ) -> types.Resume:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            # Use streaming internally when on_tick is provided
            stream = self.stream.ExtractResume(resume=resume,
                baml_options=baml_options)
            return await stream.get_final_response()
        else:
            # Original non-streaming code
            result = await self.__options.merge_options(baml_options).call_function_async(function_name="ExtractResume", args={
                "resume": resume,
            })
            return typing.cast(types.Resume, result.cast_to(types, types, stream_types, False, __runtime__))
    async def FetchHistoricalData(self, ticker: str,period: str,interval: str,
        baml_options: BamlCallOptions = {},
    ) -> typing.List["types.PricePoint"]:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            # Use streaming internally when on_tick is provided
            stream = self.stream.FetchHistoricalData(ticker=ticker,period=period,interval=interval,
                baml_options=baml_options)
            return await stream.get_final_response()
        else:
            # Original non-streaming code
            result = await self.__options.merge_options(baml_options).call_function_async(function_name="FetchHistoricalData", args={
                "ticker": ticker,"period": period,"interval": interval,
            })
            return typing.cast(typing.List["types.PricePoint"], result.cast_to(types, types, stream_types, False, __runtime__))
    async def GenerateHistoricalAnalysisReport(self, ticker: str,period: str,benchmark: str,interval: str,
        baml_options: BamlCallOptions = {},
    ) -> types.ComprehensiveReport:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            # Use streaming internally when on_tick is provided
            stream = self.stream.GenerateHistoricalAnalysisReport(ticker=ticker,period=period,benchmark=benchmark,interval=interval,
                baml_options=baml_options)
            return await stream.get_final_response()
        else:
            # Original non-streaming code
            result = await self.__options.merge_options(baml_options).call_function_async(function_name="GenerateHistoricalAnalysisReport", args={
                "ticker": ticker,"period": period,"benchmark": benchmark,"interval": interval,
            })
            return typing.cast(types.ComprehensiveReport, result.cast_to(types, types, stream_types, False, __runtime__))
    async def GenerateInsiderReport(self, ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> types.InsiderAnalysisReport:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            # Use streaming internally when on_tick is provided
            stream = self.stream.GenerateInsiderReport(ticker=ticker,
                baml_options=baml_options)
            return await stream.get_final_response()
        else:
            # Original non-streaming code
            result = await self.__options.merge_options(baml_options).call_function_async(function_name="GenerateInsiderReport", args={
                "ticker": ticker,
            })
            return typing.cast(types.InsiderAnalysisReport, result.cast_to(types, types, stream_types, False, __runtime__))
    async def GenerateMarketConditionsReport(self, 
        baml_options: BamlCallOptions = {},
    ) -> types.MarketConditionsAnalysisReport:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            # Use streaming internally when on_tick is provided
            stream = self.stream.GenerateMarketConditionsReport(
                baml_options=baml_options)
            return await stream.get_final_response()
        else:
            # Original non-streaming code
            result = await self.__options.merge_options(baml_options).call_function_async(function_name="GenerateMarketConditionsReport", args={
                
            })
            return typing.cast(types.MarketConditionsAnalysisReport, result.cast_to(types, types, stream_types, False, __runtime__))
    async def GenerateNewsReport(self, ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> types.NewsAnalysisReport:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            # Use streaming internally when on_tick is provided
            stream = self.stream.GenerateNewsReport(ticker=ticker,
                baml_options=baml_options)
            return await stream.get_final_response()
        else:
            # Original non-streaming code
            result = await self.__options.merge_options(baml_options).call_function_async(function_name="GenerateNewsReport", args={
                "ticker": ticker,
            })
            return typing.cast(types.NewsAnalysisReport, result.cast_to(types, types, stream_types, False, __runtime__))
    async def GenerateSentimentAnalysisReport(self, ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> types.SentimentAnalysisReport:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            # Use streaming internally when on_tick is provided
            stream = self.stream.GenerateSentimentAnalysisReport(ticker=ticker,
                baml_options=baml_options)
            return await stream.get_final_response()
        else:
            # Original non-streaming code
            result = await self.__options.merge_options(baml_options).call_function_async(function_name="GenerateSentimentAnalysisReport", args={
                "ticker": ticker,
            })
            return typing.cast(types.SentimentAnalysisReport, result.cast_to(types, types, stream_types, False, __runtime__))
    async def GenerateVolatilityReport(self, ticker: str,period: str,benchmark: str,
        baml_options: BamlCallOptions = {},
    ) -> types.VolatilityAnalysisReport:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            # Use streaming internally when on_tick is provided
            stream = self.stream.GenerateVolatilityReport(ticker=ticker,period=period,benchmark=benchmark,
                baml_options=baml_options)
            return await stream.get_final_response()
        else:
            # Original non-streaming code
            result = await self.__options.merge_options(baml_options).call_function_async(function_name="GenerateVolatilityReport", args={
                "ticker": ticker,"period": period,"benchmark": benchmark,
            })
            return typing.cast(types.VolatilityAnalysisReport, result.cast_to(types, types, stream_types, False, __runtime__))
    async def GetStockInfo(self, ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> types.StockData:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            # Use streaming internally when on_tick is provided
            stream = self.stream.GetStockInfo(ticker=ticker,
                baml_options=baml_options)
            return await stream.get_final_response()
        else:
            # Original non-streaming code
            result = await self.__options.merge_options(baml_options).call_function_async(function_name="GetStockInfo", args={
                "ticker": ticker,
            })
            return typing.cast(types.StockData, result.cast_to(types, types, stream_types, False, __runtime__))
    


class BamlStreamClient:
    __options: DoNotUseDirectlyCallManager

    def __init__(self, options: DoNotUseDirectlyCallManager):
        self.__options = options

    def AnalyzeInsiderActivity(self, transactions: typing.List["types.InsiderTrade"],ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[stream_types.InsiderActivitySummary, types.InsiderActivitySummary]:
        ctx, result = self.__options.merge_options(baml_options).create_async_stream(function_name="AnalyzeInsiderActivity", args={
            "transactions": transactions,"ticker": ticker,
        })
        return baml_py.BamlStream[stream_types.InsiderActivitySummary, types.InsiderActivitySummary](
          result,
          lambda x: typing.cast(stream_types.InsiderActivitySummary, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.InsiderActivitySummary, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def AnalyzeNewsSentiment(self, articles: typing.List["types.NewsArticle"],ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[stream_types.NewsSentimentAnalysis, types.NewsSentimentAnalysis]:
        ctx, result = self.__options.merge_options(baml_options).create_async_stream(function_name="AnalyzeNewsSentiment", args={
            "articles": articles,"ticker": ticker,
        })
        return baml_py.BamlStream[stream_types.NewsSentimentAnalysis, types.NewsSentimentAnalysis](
          result,
          lambda x: typing.cast(stream_types.NewsSentimentAnalysis, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.NewsSentimentAnalysis, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def AnalyzeNewsSentimentForSentiment(self, ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[stream_types.SentimentSource, types.SentimentSource]:
        ctx, result = self.__options.merge_options(baml_options).create_async_stream(function_name="AnalyzeNewsSentimentForSentiment", args={
            "ticker": ticker,
        })
        return baml_py.BamlStream[stream_types.SentimentSource, types.SentimentSource](
          result,
          lambda x: typing.cast(stream_types.SentimentSource, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.SentimentSource, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def AnalyzeOptionsSentiment(self, ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[stream_types.OptionsFlow, types.OptionsFlow]:
        ctx, result = self.__options.merge_options(baml_options).create_async_stream(function_name="AnalyzeOptionsSentiment", args={
            "ticker": ticker,
        })
        return baml_py.BamlStream[stream_types.OptionsFlow, types.OptionsFlow](
          result,
          lambda x: typing.cast(stream_types.OptionsFlow, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.OptionsFlow, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def AnalyzePricePerformance(self, price_data: typing.List["types.PricePoint"],ticker: str,period: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[stream_types.PriceAnalysis, types.PriceAnalysis]:
        ctx, result = self.__options.merge_options(baml_options).create_async_stream(function_name="AnalyzePricePerformance", args={
            "price_data": price_data,"ticker": ticker,"period": period,
        })
        return baml_py.BamlStream[stream_types.PriceAnalysis, types.PriceAnalysis](
          result,
          lambda x: typing.cast(stream_types.PriceAnalysis, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.PriceAnalysis, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def AnalyzeSectorPerformance(self, 
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[typing.List["stream_types.SectorPerformance"], typing.List["types.SectorPerformance"]]:
        ctx, result = self.__options.merge_options(baml_options).create_async_stream(function_name="AnalyzeSectorPerformance", args={
            
        })
        return baml_py.BamlStream[typing.List["stream_types.SectorPerformance"], typing.List["types.SectorPerformance"]](
          result,
          lambda x: typing.cast(typing.List["stream_types.SectorPerformance"], x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(typing.List["types.SectorPerformance"], x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def AnalyzeSocialSentiment(self, ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[stream_types.SentimentSource, types.SentimentSource]:
        ctx, result = self.__options.merge_options(baml_options).create_async_stream(function_name="AnalyzeSocialSentiment", args={
            "ticker": ticker,
        })
        return baml_py.BamlStream[stream_types.SentimentSource, types.SentimentSource](
          result,
          lambda x: typing.cast(stream_types.SentimentSource, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.SentimentSource, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def CalculateTechnicalIndicators(self, price_data: typing.List["types.PricePoint"],ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[stream_types.TechnicalIndicators, types.TechnicalIndicators]:
        ctx, result = self.__options.merge_options(baml_options).create_async_stream(function_name="CalculateTechnicalIndicators", args={
            "price_data": price_data,"ticker": ticker,
        })
        return baml_py.BamlStream[stream_types.TechnicalIndicators, types.TechnicalIndicators](
          result,
          lambda x: typing.cast(stream_types.TechnicalIndicators, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.TechnicalIndicators, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def CalculateVolatilityMetrics(self, price_data: typing.List["types.PricePoint"],ticker: str,benchmark_data: typing.List["types.PricePoint"],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[stream_types.VolatilityMetrics, types.VolatilityMetrics]:
        ctx, result = self.__options.merge_options(baml_options).create_async_stream(function_name="CalculateVolatilityMetrics", args={
            "price_data": price_data,"ticker": ticker,"benchmark_data": benchmark_data,
        })
        return baml_py.BamlStream[stream_types.VolatilityMetrics, types.VolatilityMetrics](
          result,
          lambda x: typing.cast(stream_types.VolatilityMetrics, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.VolatilityMetrics, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def CompareToMarket(self, ticker: str,price_data: typing.List["types.PricePoint"],benchmark_ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[stream_types.MarketComparison, types.MarketComparison]:
        ctx, result = self.__options.merge_options(baml_options).create_async_stream(function_name="CompareToMarket", args={
            "ticker": ticker,"price_data": price_data,"benchmark_ticker": benchmark_ticker,
        })
        return baml_py.BamlStream[stream_types.MarketComparison, types.MarketComparison](
          result,
          lambda x: typing.cast(stream_types.MarketComparison, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.MarketComparison, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def ExtractResume(self, resume: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[stream_types.Resume, types.Resume]:
        ctx, result = self.__options.merge_options(baml_options).create_async_stream(function_name="ExtractResume", args={
            "resume": resume,
        })
        return baml_py.BamlStream[stream_types.Resume, types.Resume](
          result,
          lambda x: typing.cast(stream_types.Resume, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.Resume, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def FetchHistoricalData(self, ticker: str,period: str,interval: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[typing.List["stream_types.PricePoint"], typing.List["types.PricePoint"]]:
        ctx, result = self.__options.merge_options(baml_options).create_async_stream(function_name="FetchHistoricalData", args={
            "ticker": ticker,"period": period,"interval": interval,
        })
        return baml_py.BamlStream[typing.List["stream_types.PricePoint"], typing.List["types.PricePoint"]](
          result,
          lambda x: typing.cast(typing.List["stream_types.PricePoint"], x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(typing.List["types.PricePoint"], x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def GenerateHistoricalAnalysisReport(self, ticker: str,period: str,benchmark: str,interval: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[stream_types.ComprehensiveReport, types.ComprehensiveReport]:
        ctx, result = self.__options.merge_options(baml_options).create_async_stream(function_name="GenerateHistoricalAnalysisReport", args={
            "ticker": ticker,"period": period,"benchmark": benchmark,"interval": interval,
        })
        return baml_py.BamlStream[stream_types.ComprehensiveReport, types.ComprehensiveReport](
          result,
          lambda x: typing.cast(stream_types.ComprehensiveReport, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.ComprehensiveReport, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def GenerateInsiderReport(self, ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[stream_types.InsiderAnalysisReport, types.InsiderAnalysisReport]:
        ctx, result = self.__options.merge_options(baml_options).create_async_stream(function_name="GenerateInsiderReport", args={
            "ticker": ticker,
        })
        return baml_py.BamlStream[stream_types.InsiderAnalysisReport, types.InsiderAnalysisReport](
          result,
          lambda x: typing.cast(stream_types.InsiderAnalysisReport, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.InsiderAnalysisReport, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def GenerateMarketConditionsReport(self, 
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[stream_types.MarketConditionsAnalysisReport, types.MarketConditionsAnalysisReport]:
        ctx, result = self.__options.merge_options(baml_options).create_async_stream(function_name="GenerateMarketConditionsReport", args={
            
        })
        return baml_py.BamlStream[stream_types.MarketConditionsAnalysisReport, types.MarketConditionsAnalysisReport](
          result,
          lambda x: typing.cast(stream_types.MarketConditionsAnalysisReport, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.MarketConditionsAnalysisReport, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def GenerateNewsReport(self, ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[stream_types.NewsAnalysisReport, types.NewsAnalysisReport]:
        ctx, result = self.__options.merge_options(baml_options).create_async_stream(function_name="GenerateNewsReport", args={
            "ticker": ticker,
        })
        return baml_py.BamlStream[stream_types.NewsAnalysisReport, types.NewsAnalysisReport](
          result,
          lambda x: typing.cast(stream_types.NewsAnalysisReport, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.NewsAnalysisReport, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def GenerateSentimentAnalysisReport(self, ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[stream_types.SentimentAnalysisReport, types.SentimentAnalysisReport]:
        ctx, result = self.__options.merge_options(baml_options).create_async_stream(function_name="GenerateSentimentAnalysisReport", args={
            "ticker": ticker,
        })
        return baml_py.BamlStream[stream_types.SentimentAnalysisReport, types.SentimentAnalysisReport](
          result,
          lambda x: typing.cast(stream_types.SentimentAnalysisReport, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.SentimentAnalysisReport, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def GenerateVolatilityReport(self, ticker: str,period: str,benchmark: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[stream_types.VolatilityAnalysisReport, types.VolatilityAnalysisReport]:
        ctx, result = self.__options.merge_options(baml_options).create_async_stream(function_name="GenerateVolatilityReport", args={
            "ticker": ticker,"period": period,"benchmark": benchmark,
        })
        return baml_py.BamlStream[stream_types.VolatilityAnalysisReport, types.VolatilityAnalysisReport](
          result,
          lambda x: typing.cast(stream_types.VolatilityAnalysisReport, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.VolatilityAnalysisReport, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def GetStockInfo(self, ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlStream[stream_types.StockData, types.StockData]:
        ctx, result = self.__options.merge_options(baml_options).create_async_stream(function_name="GetStockInfo", args={
            "ticker": ticker,
        })
        return baml_py.BamlStream[stream_types.StockData, types.StockData](
          result,
          lambda x: typing.cast(stream_types.StockData, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.StockData, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    

class BamlHttpRequestClient:
    __options: DoNotUseDirectlyCallManager

    def __init__(self, options: DoNotUseDirectlyCallManager):
        self.__options = options

    async def AnalyzeInsiderActivity(self, transactions: typing.List["types.InsiderTrade"],ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = await self.__options.merge_options(baml_options).create_http_request_async(function_name="AnalyzeInsiderActivity", args={
            "transactions": transactions,"ticker": ticker,
        }, mode="request")
        return result
    async def AnalyzeNewsSentiment(self, articles: typing.List["types.NewsArticle"],ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = await self.__options.merge_options(baml_options).create_http_request_async(function_name="AnalyzeNewsSentiment", args={
            "articles": articles,"ticker": ticker,
        }, mode="request")
        return result
    async def AnalyzeNewsSentimentForSentiment(self, ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = await self.__options.merge_options(baml_options).create_http_request_async(function_name="AnalyzeNewsSentimentForSentiment", args={
            "ticker": ticker,
        }, mode="request")
        return result
    async def AnalyzeOptionsSentiment(self, ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = await self.__options.merge_options(baml_options).create_http_request_async(function_name="AnalyzeOptionsSentiment", args={
            "ticker": ticker,
        }, mode="request")
        return result
    async def AnalyzePricePerformance(self, price_data: typing.List["types.PricePoint"],ticker: str,period: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = await self.__options.merge_options(baml_options).create_http_request_async(function_name="AnalyzePricePerformance", args={
            "price_data": price_data,"ticker": ticker,"period": period,
        }, mode="request")
        return result
    async def AnalyzeSectorPerformance(self, 
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = await self.__options.merge_options(baml_options).create_http_request_async(function_name="AnalyzeSectorPerformance", args={
            
        }, mode="request")
        return result
    async def AnalyzeSocialSentiment(self, ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = await self.__options.merge_options(baml_options).create_http_request_async(function_name="AnalyzeSocialSentiment", args={
            "ticker": ticker,
        }, mode="request")
        return result
    async def CalculateTechnicalIndicators(self, price_data: typing.List["types.PricePoint"],ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = await self.__options.merge_options(baml_options).create_http_request_async(function_name="CalculateTechnicalIndicators", args={
            "price_data": price_data,"ticker": ticker,
        }, mode="request")
        return result
    async def CalculateVolatilityMetrics(self, price_data: typing.List["types.PricePoint"],ticker: str,benchmark_data: typing.List["types.PricePoint"],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = await self.__options.merge_options(baml_options).create_http_request_async(function_name="CalculateVolatilityMetrics", args={
            "price_data": price_data,"ticker": ticker,"benchmark_data": benchmark_data,
        }, mode="request")
        return result
    async def CompareToMarket(self, ticker: str,price_data: typing.List["types.PricePoint"],benchmark_ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = await self.__options.merge_options(baml_options).create_http_request_async(function_name="CompareToMarket", args={
            "ticker": ticker,"price_data": price_data,"benchmark_ticker": benchmark_ticker,
        }, mode="request")
        return result
    async def ExtractResume(self, resume: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = await self.__options.merge_options(baml_options).create_http_request_async(function_name="ExtractResume", args={
            "resume": resume,
        }, mode="request")
        return result
    async def FetchHistoricalData(self, ticker: str,period: str,interval: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = await self.__options.merge_options(baml_options).create_http_request_async(function_name="FetchHistoricalData", args={
            "ticker": ticker,"period": period,"interval": interval,
        }, mode="request")
        return result
    async def GenerateHistoricalAnalysisReport(self, ticker: str,period: str,benchmark: str,interval: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = await self.__options.merge_options(baml_options).create_http_request_async(function_name="GenerateHistoricalAnalysisReport", args={
            "ticker": ticker,"period": period,"benchmark": benchmark,"interval": interval,
        }, mode="request")
        return result
    async def GenerateInsiderReport(self, ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = await self.__options.merge_options(baml_options).create_http_request_async(function_name="GenerateInsiderReport", args={
            "ticker": ticker,
        }, mode="request")
        return result
    async def GenerateMarketConditionsReport(self, 
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = await self.__options.merge_options(baml_options).create_http_request_async(function_name="GenerateMarketConditionsReport", args={
            
        }, mode="request")
        return result
    async def GenerateNewsReport(self, ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = await self.__options.merge_options(baml_options).create_http_request_async(function_name="GenerateNewsReport", args={
            "ticker": ticker,
        }, mode="request")
        return result
    async def GenerateSentimentAnalysisReport(self, ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = await self.__options.merge_options(baml_options).create_http_request_async(function_name="GenerateSentimentAnalysisReport", args={
            "ticker": ticker,
        }, mode="request")
        return result
    async def GenerateVolatilityReport(self, ticker: str,period: str,benchmark: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = await self.__options.merge_options(baml_options).create_http_request_async(function_name="GenerateVolatilityReport", args={
            "ticker": ticker,"period": period,"benchmark": benchmark,
        }, mode="request")
        return result
    async def GetStockInfo(self, ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = await self.__options.merge_options(baml_options).create_http_request_async(function_name="GetStockInfo", args={
            "ticker": ticker,
        }, mode="request")
        return result
    

class BamlHttpStreamRequestClient:
    __options: DoNotUseDirectlyCallManager

    def __init__(self, options: DoNotUseDirectlyCallManager):
        self.__options = options

    async def AnalyzeInsiderActivity(self, transactions: typing.List["types.InsiderTrade"],ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = await self.__options.merge_options(baml_options).create_http_request_async(function_name="AnalyzeInsiderActivity", args={
            "transactions": transactions,"ticker": ticker,
        }, mode="stream")
        return result
    async def AnalyzeNewsSentiment(self, articles: typing.List["types.NewsArticle"],ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = await self.__options.merge_options(baml_options).create_http_request_async(function_name="AnalyzeNewsSentiment", args={
            "articles": articles,"ticker": ticker,
        }, mode="stream")
        return result
    async def AnalyzeNewsSentimentForSentiment(self, ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = await self.__options.merge_options(baml_options).create_http_request_async(function_name="AnalyzeNewsSentimentForSentiment", args={
            "ticker": ticker,
        }, mode="stream")
        return result
    async def AnalyzeOptionsSentiment(self, ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = await self.__options.merge_options(baml_options).create_http_request_async(function_name="AnalyzeOptionsSentiment", args={
            "ticker": ticker,
        }, mode="stream")
        return result
    async def AnalyzePricePerformance(self, price_data: typing.List["types.PricePoint"],ticker: str,period: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = await self.__options.merge_options(baml_options).create_http_request_async(function_name="AnalyzePricePerformance", args={
            "price_data": price_data,"ticker": ticker,"period": period,
        }, mode="stream")
        return result
    async def AnalyzeSectorPerformance(self, 
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = await self.__options.merge_options(baml_options).create_http_request_async(function_name="AnalyzeSectorPerformance", args={
            
        }, mode="stream")
        return result
    async def AnalyzeSocialSentiment(self, ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = await self.__options.merge_options(baml_options).create_http_request_async(function_name="AnalyzeSocialSentiment", args={
            "ticker": ticker,
        }, mode="stream")
        return result
    async def CalculateTechnicalIndicators(self, price_data: typing.List["types.PricePoint"],ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = await self.__options.merge_options(baml_options).create_http_request_async(function_name="CalculateTechnicalIndicators", args={
            "price_data": price_data,"ticker": ticker,
        }, mode="stream")
        return result
    async def CalculateVolatilityMetrics(self, price_data: typing.List["types.PricePoint"],ticker: str,benchmark_data: typing.List["types.PricePoint"],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = await self.__options.merge_options(baml_options).create_http_request_async(function_name="CalculateVolatilityMetrics", args={
            "price_data": price_data,"ticker": ticker,"benchmark_data": benchmark_data,
        }, mode="stream")
        return result
    async def CompareToMarket(self, ticker: str,price_data: typing.List["types.PricePoint"],benchmark_ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = await self.__options.merge_options(baml_options).create_http_request_async(function_name="CompareToMarket", args={
            "ticker": ticker,"price_data": price_data,"benchmark_ticker": benchmark_ticker,
        }, mode="stream")
        return result
    async def ExtractResume(self, resume: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = await self.__options.merge_options(baml_options).create_http_request_async(function_name="ExtractResume", args={
            "resume": resume,
        }, mode="stream")
        return result
    async def FetchHistoricalData(self, ticker: str,period: str,interval: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = await self.__options.merge_options(baml_options).create_http_request_async(function_name="FetchHistoricalData", args={
            "ticker": ticker,"period": period,"interval": interval,
        }, mode="stream")
        return result
    async def GenerateHistoricalAnalysisReport(self, ticker: str,period: str,benchmark: str,interval: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = await self.__options.merge_options(baml_options).create_http_request_async(function_name="GenerateHistoricalAnalysisReport", args={
            "ticker": ticker,"period": period,"benchmark": benchmark,"interval": interval,
        }, mode="stream")
        return result
    async def GenerateInsiderReport(self, ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = await self.__options.merge_options(baml_options).create_http_request_async(function_name="GenerateInsiderReport", args={
            "ticker": ticker,
        }, mode="stream")
        return result
    async def GenerateMarketConditionsReport(self, 
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = await self.__options.merge_options(baml_options).create_http_request_async(function_name="GenerateMarketConditionsReport", args={
            
        }, mode="stream")
        return result
    async def GenerateNewsReport(self, ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = await self.__options.merge_options(baml_options).create_http_request_async(function_name="GenerateNewsReport", args={
            "ticker": ticker,
        }, mode="stream")
        return result
    async def GenerateSentimentAnalysisReport(self, ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = await self.__options.merge_options(baml_options).create_http_request_async(function_name="GenerateSentimentAnalysisReport", args={
            "ticker": ticker,
        }, mode="stream")
        return result
    async def GenerateVolatilityReport(self, ticker: str,period: str,benchmark: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = await self.__options.merge_options(baml_options).create_http_request_async(function_name="GenerateVolatilityReport", args={
            "ticker": ticker,"period": period,"benchmark": benchmark,
        }, mode="stream")
        return result
    async def GetStockInfo(self, ticker: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = await self.__options.merge_options(baml_options).create_http_request_async(function_name="GetStockInfo", args={
            "ticker": ticker,
        }, mode="stream")
        return result
    

b = BamlAsyncClient(DoNotUseDirectlyCallManager({}))